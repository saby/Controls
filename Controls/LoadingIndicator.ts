import {Control, IControlOptions, TemplateFunction} from 'UI/Base';
import tmpl = require('wml!Controls/_LoadingIndicator/LoadingIndicator');
import * as randomId from 'Core/helpers/Number/randomId';
import {List} from 'Types/collection';
import 'css!theme?Controls/_LoadingIndicator/LoadingIndicator';
import {ILoadingIndicatorOptions, ILoadingIndicator} from 'Controls/interface';
import {SyntheticEvent} from 'Vdom/Vdom';


/**
 * Контейнер для контента с возможностью отображения индикатора загрузки.
 * Может использоваться локально для покрытия собственного контента или глобально для покрытия всей страницы.
 * @remark
 * Контрол обрабатывает два события — showIndicator и hideIndicator.
 *
 * Событие showIndicator используется для отображения индикатора.
 * Это могут быть какие-либо запросы.
 * Запросы составляют стек, где последний обработанный запрос LoadingIndicator используется для отображения индикатора.
 * Индикатор пропадает, когда стек становится пустым.
 * Параметры события showIndicator идентичны аргументам метода {@link show}.
 *
 * Событие hideIndicator используется для удаления запроса отображения индикатора.
 * Параметры события hideIndicator идентичны аргументам метода {@link hide}.
 *
 * @class Controls/LoadingIndicator
 * @extends Core/Control
 * @mixes Controls/_interface/ILoadingIndicator
 * @control
 * @author Красильников А.С.
 * @public
 * @category Container
 * @demo Controls-demo/LoadingIndicator/Overlay/Index
 */

/*
 * Container for content that can show loading indicator.
 * It can be local using for covering it's own content or global using for covering whole page.
 * @remark
 * LoadingIndicator is waiting 2 events: showIndicator and hideIndicator.
 *
 * showIndicator is using for request of indicator showing. It may be some requests.
 * Requests compose stack where last handled request is using by LoadingIndicator for indicator showing.
 * Indicator becomes invisible when stack will be empty.
 * showIndicator has 2 arguments: [config, waitPromise].
 * config is object having properties:
 *    -  id (String) - defines the unique id of showing request (By default use autogenerated id),
 *    -  isGlobal (Boolean) - global or not (If not setted, by default use value of similar control option)
 *    -  message (String) - message of indicator (If not setted, by default use value of similar control option)
 *    -  scroll (String) - add gradient of indicator's background (If not setted, by default use value of similar control option)
 *    -  small (String) - size of indicator (If not setted, by default use value of similar control option)
 *    -  overlay (String) - setting of indicator's overlay (If not setted, by default use value of similar control option)
 *    -  mods (Array.<String>|String) - It can be using for custom tuning of indicator (If not setted, by default use value of similar control option)
 *    -  delay (Number) - timeout before indicator will be visible (If not setted, by default use value of similar control option)
 * waitPromise (Promise) - when this promise will be resolved, indicator hides (not necessary property)
 * showIndicator returns id value using as argument of hideIndicator.
 *
 * hideIndicator is using for remove request of indicator showing.
 * hideIndicator has 1 argument: [id].
 * id is Number type property. It needs for remove concrete request from stack of requests.
 *
 *
 * @css size_LoadingIndicator-l Size of Loading Indicator when option size is set to default.
 * @css size_LoadingIndicator-s Size of Loading Indicator when option size is set to small.
 *
 * @css @spacing_LoadingIndicator-between-content-border-l Spacing between content and border when option size is set to default.
 * @css @spacing_LoadingIndicator-between-content-border-s Spacing between content and border when option size is set to small.
 *
 * @css @border-radius_LoadingIndicator Border radius when option size is set to default.
 *
 * @css @font-size_LoadingIndicator Font-size of message.
 * @css @line-height_LoadingIndicator Line-height of message.
 * @css @color_LoadingIndicator-text Color of message.
 *
 * @css @color_LoadingIndicator-overlay-default Color of overlay when option overlay is set to default.
 * @css @color_LoadingIndicator-overlay-dark Color of overlay when option overlay is set to dark.
 *
 * @css @background-url_LoadingIndicator-l Background-url when option size is set to default.
 * @css @background-url_LoadingIndicator-s Background-url when options size is set to small.
 * @css @background-color_LoadingIndicator Background color of Loading Indicator.
 *
 * @class Controls/LoadingIndicator
 * @extends Core/Control
 * @mixes Controls/_interface/ILoadingIndicator
 * @control
 * @author Красильников А.С.
 * @public
 * @category Container
 * @demo Controls-demo/LoadingIndicator/Overlay/Index
 */
let ManagerController;

class LoadingIndicator extends Control<ILoadingIndicatorOptions>/** @lends Controls/LoadingIndicator.prototype */ {
    protected _template: TemplateFunction = tmpl;
    protected _isOverlayVisible: boolean = false;
    protected _isMessageVisible: boolean = false;
    protected _isPreloading: boolean = false;
    protected _prevLoading: null;
    protected _stack = null;
    protected _isLoadingSaved = null;
    protected _delay: number = 2000;
    protected _mods: Array<string> | string;
    protected _zIndex: number;
    protected _delayTimeout;
    protected _toggleOverlayTimerId;

    protected _beforeMount(options: ILoadingIndicatorOptions): void {
        this._mods = [];
        this._stack = new List();
        this._updateProperties(options);
    }

    protected _afterMount(cfg): void {
        const self = this;
        if (cfg.mainIndicator) {
            requirejs(['Controls/popup'], function (popup) {
                // TODO: Индикатор сейчас напрямую зависит от Controls/popup и наоборот
                // Надо либо пересмотреть формирование библиотек и включить LoadingIndicator в popup,
                // Либо переписать индикатор так, чтобы зависимостей от Controls/popup не было.
                ManagerController = popup.Controller;
                ManagerController.setIndicator(self);
            });
        }
    }

    protected _beforeUpdate(options: ILoadingIndicatorOptions): void {
        this._updateProperties(options);
    }

    protected _updateProperties(options: ILoadingIndicatorOptions): void {
        if (options.mods !== undefined) {
            // todo сделать mods строкой всегда, или вообще удалить опцию
            if (Array.isArray(options.mods)) {
                this._mods = options.mods;
            } else if (typeof options.mods === 'string') {
                this._mods = [options.mods];
            }
        }
        this._delay = options.delay !== undefined ? options.delay : 2000;
    }

    // Indicator is opened above existing popups.
    protected _updateZIndex(config) {
        const popupItem = ManagerController && ManagerController.find((config || {}).popupId);
        if (popupItem) {
            this._zIndex = popupItem.currentZIndex;
        } else {
            this._zIndex = null;
        }
    }

    protected _showHandler(event: SyntheticEvent<Event>, config: ILoadingIndicatorOptions, waitPromise: Promise<any>) {
        event.stopPropagation();
        return this._show(config, waitPromise);
    }

    protected _hideHandler(event: SyntheticEvent<Event>, id) {
        event.stopPropagation();
        return this._hide(id);
    }

    /*
     * show indicator (bypassing requests of indicator showing stack)
     */
    /**
     * Отображает индикатор загрузки.
     * @function
     * @name Controls/LoadingIndicator#show
     * @param {Object} [config] Объект с параметрами. Если не задан, по умолчанию используется значение аналогичного параметра контрола.
     * @param {Boolean} [config.isGlobal=true] Определяет, глобальный или нет идентификатор.
     * @param {String} [config.message=''] Текст сообщения индикатора.
     * @param {Scroll} [config.scroll=''] Добавляет градиент фону индикатора.
     * @param {Small} [config.small=''] Размер индикатора.
     * @param {Overlay} [config.overlay=default] Настройки оверлея индикатора.
     * @param {Array.<String>|String} [config.mods] Может использоваться для пользовательской настройки индикатора.
     * @param {Number} [config.delay=2000] Задержка перед началом показа индикатора.
     * @param {Promise} [waitPromise] Promise, к которому привязывается отображение индикатора. Индикатор скроется после завершения Promise.
     * @return {Number} Возвращает id индикатора загрузки. Используется в методе {@link hide} для закрытия индикатора.
     * @see hide
     */
    show(config: ILoadingIndicatorOptions, waitPromise: Promise<any>): string {
        return this._show(config, waitPromise);
    }

    protected _show(config: ILoadingIndicatorOptions, waitPromise: Promise<any>): string {
        const newCfg = this._prepareConfig(config, waitPromise);
        const isOpened = this._getItemIndex(newCfg.id) > -1;
        if (isOpened) {
            this._replaceItem(newCfg.id, newCfg);
            this._updateProperties(newCfg);
        } else {
            this._stack.add(newCfg);
            this._toggleIndicator(true, newCfg);
        }
        return newCfg.id;
    }

    /*
     * hide indicator (bypassing requests of indicator showing stack)
     */
    /**
     * Скрывает индикатор загрузки.
     * @function
     * @name Controls/LoadingIndicator#hide
     * @param {Number} id Идентификатор индикатора загрузки.
     * @see show
     */
    hide(id: string): void {
        if (!id) {

            // Used public api. In this case, hide the indicator immediately.
            this._clearStack();
            this._toggleIndicator(false, {});
        } else {
            this._hide(id);
        }
    }

    protected _hide(id: string): void {
        this._removeItem(id);
        if (this._stack.getCount()) {
            this._toggleIndicator(true, this._stack.at(this._stack.getCount() - 1), true);
        } else {
            this._toggleIndicator(false);
        }
    }

    protected _clearStack(): void {
        this._stack.clear();
    }

    protected _isOpened(config?: ILoadingIndicatorOptions) {
        // config is not required parameter. If config object is empty we should always create new Indicator due to absence of ID field in config
        if (!config) {
            return false;
        }
        const index = this._getItemIndex(config.id);
        if (index < 0) {
            delete config.id;
        }
        return !!config.id;
    }

    protected _waitPromiseHandler(config: ILoadingIndicatorOptions): void {
        if (this._isOpened(config)) {
            this._hide(config.id);
        }
    }

    protected _prepareConfig(config: ILoadingIndicatorOptions, waitPromise: Promise<any>): ILoadingIndicatorOptions {
        if (typeof config !== 'object') {
            config = {
                message: config
            };
        }
        if (!config.hasOwnProperty('overlay')) {
            config.overlay = 'default';
        }
        if (!config.id) {
            config.id = randomId();
        }
        if (!config.hasOwnProperty('delay')) {
            config.delay = this._delay;
        }

        if (!config.waitPromise && waitPromise) {
            config.waitPromise = waitPromise;
            config.waitPromise.then(this._waitPromiseHandler.bind(this, config));
            config.waitPromise.catch(this._waitPromiseHandler.bind(this, config));
        }
        return config;
    }

    protected _removeItem(id: string): void {
        const index = this._getItemIndex(id);
        if (index > -1) {
            this._stack.removeAt(index);
        }
    }

    protected _replaceItem(id: string, config: ILoadingIndicatorOptions) {
        this._removeItem(id);
        this._stack.add(config);
    }

    protected _getItemIndex(id: string) {
        return this._stack.getIndexByValue('id', id);
    }

    protected _getDelay(config: ILoadingIndicatorOptions): number {
        return typeof config.delay === 'number' ? config.delay : this._delay;
    }

    protected _getOverlay(overlay: string): string {
        // if overlay is visible, but message don't visible, then overlay must be transparent.
        if (this._isOverlayVisible && !this._isMessageVisible) {
            return 'default';
        }
        return overlay;
    }

    protected _toggleIndicator(visible: boolean, config?: ILoadingIndicatorOptions, force?): void {
        clearTimeout(this._delayTimeout);
        this._updateZIndex(config);
        if (visible) {
            this._toggleOverlayAsync(true, config);
            if (force) {
                this._toggleIndicatorVisible(true, config);
            } else {
                // if we have indicator in stack, then don't hide overlay
                this._toggleIndicatorVisible(this._stack.getCount() > 1 && this._isOverlayVisible, config);
                this._delayTimeout = setTimeout(() => {
                    const lastIndex = this._stack.getCount() - 1;
                    if (lastIndex > -1) {
                        this._toggleIndicatorVisible(true, this._stack.at(lastIndex));
                        this._forceUpdate();
                    }
                }, this._getDelay(config));
            }
        } else {
            // if we dont't have indicator in stack, then hide overlay
            if (this._stack.getCount() === 0) {
                this._toggleIndicatorVisible(false);
                this._toggleOverlayAsync(false, {});
            }
        }
        this._forceUpdate();
    }

    protected _toggleOverlayAsync(toggle: boolean, config: ILoadingIndicatorOptions): void {
        // контролы, которые при ховере показывают окно, теряют свой ховер при показе оверлея,
        // что влечет за собой вызов обработчиков на mouseout + визуально дергается ховер таргета.
        // Делаю небольшую задержку, если окно не имеет в себе асинхронного кода, то оно успеет показаться раньше
        // чем покажется оверлей. Актуально для инфобокса, превьюера и выпадающего списка.
        // Увеличил до 100мс, за меньшее время не во всех браузерах успевает отрсиоваться окно даже без асинхронных фаз
        this._clearOverlayTimerId();
        const delay = Math.min(this._getDelay(config), 100);
        this._toggleOverlayTimerId = setTimeout(() => {
            this._toggleOverlay(toggle, config);
        }, delay);
    }

    protected _toggleOverlay(toggle: boolean, config: ILoadingIndicatorOptions): void {
        this._isOverlayVisible = toggle && config.overlay !== 'none';
        this._forceUpdate();
    }

    protected _clearOverlayTimerId(): void {
        if (this._toggleOverlayTimerId) {
            clearTimeout(this._toggleOverlayTimerId);
        }
    }

    protected _toggleIndicatorVisible(toggle: boolean, config?: ILoadingIndicatorOptions): void {
        if (toggle) {
            this._clearOverlayTimerId();
            this._isMessageVisible = true;
            this._isOverlayVisible = true;
            this._updateProperties(config);
        } else {
            this._isMessageVisible = false;
        }
    }

    static getDefaultOptions(): object {
        return {
            delay: 2000,
            isGlobal: true,
            message: '',
            scroll: '',
            small: '',
            overlay: 'default',
            mods: null
        };
    }

};

export default LoadingIndicator;
